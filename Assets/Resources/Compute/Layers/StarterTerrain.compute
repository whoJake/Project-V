#pragma kernel Generate
#include "../Noise/Fractal.cginc"
#include "../MathUtils.cginc"

struct NoiseArg{
    float3 scale;
    int octaves;
    float frequency;
    float persistance;
    float lacunarity;
};

StructuredBuffer<NoiseArg> _NoiseArgs;

RWTexture3D<float> _Target;

StructuredBuffer<float3> _PlatformBuffer;
float2 _PlatformRadiusRange;
float _PlatformShapeFeatureRadius;
float _PlatformTopDisplacement;
float2 _PlatformFlatnessRange;

float2 _PlatformStemPinchRange;
float2 _PlatformStemRadius;
float _PlatformStemFeatureDepth;

float _UpperSurfaceDepth;
float _UpperSurfaceFeatureDepth;
float2 _CliffLedgeSize;

float _UpperRadius;
float _LowerRadius;
float _CliffFeatureDepth;
int _CliffSlopeEasePower;

int    _Seed;

float3 _ChunkOrigin;
float3 _ChunkSize;
float  _VoxelScale;

float3 _LayerOrigin;
float3 _LayerSize;

float _ChasmRadius;

float GetNormalizedHeightAtRadius(float radius){
    float linear_height = invlerp(radius, _UpperRadius, _LowerRadius);
    return easein( linear_height, 1.0 / _CliffSlopeEasePower );
}

float GetRadiusAtNormalizedHeight(float layer_normalized_height){
    float eased_height = easein( layer_normalized_height, _CliffSlopeEasePower );
    return lerp( _UpperRadius, _LowerRadius, eased_height );
}

//. -1 = 16 inside surface, 0, on surface, 1 = 16 outside surface
float GetSignedBaseSurfaceDistance(float3 world_position){
    float layer_normalized_height = ( -( world_position.y - _LayerOrigin.y ) ) / _LayerSize.y;
    float current_radius = GetRadiusAtNormalizedHeight( layer_normalized_height );

    float dst_from_centre = distance( world_position.xz, _LayerOrigin.xz );
    return clamp( ( dst_from_centre - current_radius ) / _CliffFeatureDepth, -1, 1 );
}

float GetBaseShape(float3 world_position, float signed_dst_base_surface){
    float base = saturate( signed_dst_base_surface + 0.5 );

    NoiseArg surface_noise_args = _NoiseArgs[4];
    float surface_noise = fnoise01( world_position * surface_noise_args.scale, surface_noise_args.octaves, surface_noise_args.frequency, surface_noise_args.persistance, surface_noise_args.lacunarity );

    return base + ( 1 - abs( signed_dst_base_surface ) ) * surface_noise;
}

float GetTopSurfaceMask(float3 world_position){
    float surface_world_height = _LayerOrigin.y - _UpperSurfaceDepth;
    float radius_at_surface = GetRadiusAtNormalizedHeight( -surface_world_height / _LayerSize.y );
    float lip_mask = saturate( ( abs( distance( world_position.xz, _LayerOrigin.xz ) - radius_at_surface ) ) / _CliffLedgeSize.x );
    surface_world_height -= easeinout( lip_mask, 4 ) * _CliffLedgeSize.y;

    NoiseArg top_surface_noise_args = _NoiseArgs[5];
    float3 sample_position = float3( world_position.x, _LayerOrigin.y, world_position.z );
    float top_surface_noise = fnoise01( sample_position * top_surface_noise_args.scale, top_surface_noise_args.octaves, top_surface_noise_args.frequency, top_surface_noise_args.persistance, top_surface_noise_args.lacunarity ) * 2 - 1;
    float noise_mask = 1 - saturate( abs( surface_world_height - world_position.y ) / _UpperSurfaceFeatureDepth );

    surface_world_height += top_surface_noise * noise_mask * max( 0.8, lip_mask ) * _UpperSurfaceFeatureDepth;

    return 1 - saturate( ( world_position.y - surface_world_height ) / _UpperSurfaceFeatureDepth );
}

float GetChasmMask(float3 world_position){
    //Possibly room to remove some temp variables here
    float3 chasm_centre = float3( _LayerOrigin.x, world_position.y, _LayerOrigin.z );
    float chasm_radius = _ChasmRadius;

    float dst_from_centre = distance( world_position, chasm_centre );

    float3 radial_dir = normalize( world_position - chasm_centre );
    float3 radial_position = chasm_centre + radial_dir * chasm_radius;
    NoiseArg radial_args = _NoiseArgs[2];
    float radial_noise = fnoise01( radial_position * radial_args.scale, radial_args.octaves, radial_args.frequency, radial_args.persistance, radial_args.lacunarity ) * 2 - 1;

    chasm_radius += radial_noise * min( 10, chasm_radius * 0.1 );

    float chasm_mask = saturate( ( dst_from_centre - chasm_radius ) / ( 16.0 ) );
    return chasm_mask;
}

float GetPlatformValue(float3 world_position){
    uint platform_count, filler;
    _PlatformBuffer.GetDimensions( platform_count, filler );

    float platform_total = 0;
    for( uint i = 0; i < platform_count; i++ ){
        float3 platform_position = _PlatformBuffer[i];
        float noise01 = snoise01( platform_position );
        float platform_radius = lerp( _PlatformRadiusRange.x, _PlatformRadiusRange.y, noise01 );
        float platform_flatness = lerp( _PlatformFlatnessRange.x, _PlatformFlatnessRange.y, 1 - noise01 );

        float3 radial_dir = normalize( world_position - platform_position );
        platform_radius -= saturate( abs( dot( radial_dir, float3( 0, 1, 0 ) ) ) ) * platform_radius * platform_flatness;

        float3 radial_position = platform_position + radial_dir * platform_radius;
        NoiseArg radial_args = _NoiseArgs[0];
        float radial_noise = fnoise01( radial_position * radial_args.scale, radial_args.octaves, radial_args.frequency, radial_args.persistance, radial_args.lacunarity ) * 2 - 1;

        platform_radius += radial_noise * platform_radius * _PlatformShapeFeatureRadius;
        
        NoiseArg above_platform_args = _NoiseArgs[3];
        float3 world_position_at_platform = float3( world_position.x, platform_position.y, world_position.z );
        float above_noise = fnoise( world_position_at_platform, above_platform_args.octaves, above_platform_args.frequency, above_platform_args.persistance, above_platform_args.lacunarity );

        float vertical_dst_from_platform = world_position.y - platform_position.y - ( platform_radius * 0.1 ) - ( above_noise * _PlatformTopDisplacement ); //pos above, neg below
        float side_multiplier = saturate( -( vertical_dst_from_platform / ( platform_radius * 0.1 ) ) );
        //. 1 radius above, -1 radius below, 0 at platform height


        NoiseArg platform_args = _NoiseArgs[1];
        float platform_shape_noise = fnoise01( world_position, platform_args.octaves, platform_args.frequency, platform_args.persistance, platform_args.lacunarity );
        platform_shape_noise = ( platform_shape_noise * 2 - 1 );
        
        float dst_from_platform = distance( world_position, platform_position );
        float radius_mask = saturate( -( dst_from_platform - platform_radius ) / ( 32.0 ) );

        //. 3D shape noise NOT currently implemented
        float current_platform_shape = saturate( radius_mask * side_multiplier );



        //Underneath pillar shape
        float radius_at_height = distance( platform_position.xz, _LayerOrigin.xz );
        float height_of_slope_below_platform = _LayerOrigin.y - GetNormalizedHeightAtRadius( radius_at_height ) * _LayerSize.y;

        float normalized_platform_to_slope_height = invlerp( world_position.y, platform_position.y, height_of_slope_below_platform );
        bool stem_multiplier = radius_at_height > _ChasmRadius && radius_at_height > _LowerRadius && normalized_platform_to_slope_height > 0 && world_position.y < platform_position.y;
        
        float stem_radius_t = abs( saturate( remap( saturate( normalized_platform_to_slope_height ), _PlatformStemPinchRange.x, _PlatformStemPinchRange.y, 0, 1 ) ) - 0.5 ) * 2;
        stem_radius_t = easeinout( stem_radius_t, 3 );

        float stem_radius = lerp( _PlatformStemRadius.x, _PlatformStemRadius.y, stem_radius_t );

        NoiseArg stem_radius_noise_args = _NoiseArgs[6];
        float3 stem_centre = float3( platform_position.x, world_position.y, platform_position.z );
        float3 stem_radius_noise_sample_position = stem_centre + normalize( world_position - stem_centre ) * stem_radius;
        float stem_radius_noise = fnoise01( stem_radius_noise_sample_position * stem_radius_noise_args.scale, stem_radius_noise_args.octaves, stem_radius_noise_args.frequency, stem_radius_noise_args.persistance, stem_radius_noise_args.lacunarity ) * 2 - 1;
        stem_radius += stem_radius_noise * _PlatformStemFeatureDepth;

        float dst_from_stem_centre = distance( world_position.xz, platform_position.xz );

        float platform_stem_shape = saturate( -( dst_from_stem_centre - stem_radius ) / 32.0 );
        
        platform_total += max( current_platform_shape, platform_stem_shape * stem_multiplier );
    }

    return platform_total;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    uint w, h, d;
    _Target.GetDimensions(w, h, d);
    if (id.x >= w || id.y >= h || id.z >= d) return;
    uint3 texture_size = uint3(w, h, d);

    float3 world_position = _ChunkOrigin + ( id * _VoxelScale );
    float3 inlayer_position = world_position - _LayerOrigin;

    float signed_dst_base_surface = GetSignedBaseSurfaceDistance( world_position );
    float base_surface = GetBaseShape( world_position, signed_dst_base_surface );
    float top_surface_mask = GetTopSurfaceMask( world_position );

    float platform = GetPlatformValue( world_position );
    float chasm = GetChasmMask( world_position );

    _Target[id] = max( base_surface * top_surface_mask, platform );
}
