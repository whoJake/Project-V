#pragma kernel Generate
#include "../Noise/Fractal.cginc"
#include "../MathUtils.cginc"

struct NoiseArg{
    float3 scale;
    int octaves;
    float frequency;
    float persistance;
    float lacunarity;
};

StructuredBuffer<NoiseArg> _NoiseArgs;

RWTexture3D<float> _Target;

StructuredBuffer<float3> _PlatformBuffer;
float2 _PlatformRadiusRange;
float _PlatformTopDisplacement;
float2 _PlatformFlatnessRange;

float _TopSurfaceRadius;
float _BottomSurfaceRadius;
float _CliffFeatureDepth;

int    _Seed;

float3 _ChunkOrigin;
float3 _ChunkSize;
float  _VoxelScale;

float3 _LayerOrigin;
float3 _LayerSize;

float _ChasmRadius;

//. -1 = 16 inside surface, 0, on surface, 1 = 16 outside surface
float GetSignedBaseSurfaceDistance(float3 world_position){
    float layer_normalized_height = ( -( world_position.y - _LayerOrigin.y ) ) / _LayerSize.y;
    float layer_eased_height = easein( layer_normalized_height , 5 );

    float dst_from_centre = distance( world_position.xz, _LayerOrigin.xz );

    float current_radius = lerp( _TopSurfaceRadius, _BottomSurfaceRadius, layer_eased_height );
    float signed_dst_base_surface = clamp( ( dst_from_centre - current_radius ) / _CliffFeatureDepth, -1, 1 );

    return signed_dst_base_surface;
}

float GetBaseShape(float3 world_position, float signed_dst_base_surface){
    float base = saturate( signed_dst_base_surface + 0.5 );

    NoiseArg surface_noise_args = _NoiseArgs[4];
    float surface_noise = fnoise01( world_position * surface_noise_args.scale, surface_noise_args.octaves, surface_noise_args.frequency, surface_noise_args.persistance, surface_noise_args.lacunarity );

    float surface_shape = base + ( 1 - abs( signed_dst_base_surface ) ) * surface_noise;

    return surface_shape;
}

float GetChasmMask(float3 world_position){
    //Possibly room to remove some temp variables here
    float3 chasm_centre = float3( _LayerOrigin.x, world_position.y, _LayerOrigin.z );
    float chasm_radius = _ChasmRadius;

    float dst_from_centre = distance( world_position, chasm_centre );

    float3 radial_dir = normalize( world_position - chasm_centre );
    float3 radial_position = chasm_centre + radial_dir * chasm_radius;
    NoiseArg radial_args = _NoiseArgs[2];
    float radial_noise = fnoise01( radial_position, radial_args.octaves, radial_args.frequency, radial_args.persistance, radial_args.lacunarity ) * 2 - 1;

    chasm_radius += radial_noise * min( 10, chasm_radius * 0.1 );

    float chasm_mask = 1 - saturate( -( dst_from_centre - chasm_radius ) / ( chasm_radius * 0.1 ) );
    return chasm_mask;
}

float GetPlatformValue(float3 world_position){
    uint platform_count, filler;
    _PlatformBuffer.GetDimensions( platform_count, filler );

    float platform_total = 0;
    for( uint i = 0; i < platform_count; i++ ){
        float3 platform_position = _PlatformBuffer[i];
        float noise01 = snoise01( platform_position );
        float platform_radius = lerp( _PlatformRadiusRange.x, _PlatformRadiusRange.y, noise01 );
        float platform_flatness = lerp( _PlatformFlatnessRange.x, _PlatformFlatnessRange.y, 1 - noise01 );

        float3 radial_dir = normalize( world_position - platform_position );
        platform_radius -= saturate( abs( dot( radial_dir, float3( 0, 1, 0 ) ) ) ) * platform_radius * platform_flatness;

        float3 radial_position = platform_position + radial_dir * platform_radius;
        NoiseArg radial_args = _NoiseArgs[0];
        float radial_noise = fnoise01( radial_position, radial_args.octaves, radial_args.frequency, radial_args.persistance, radial_args.lacunarity ) * 2 - 1;

        platform_radius += radial_noise * platform_radius * 0.25;
        
        NoiseArg above_platform_args = _NoiseArgs[3];
        float3 world_position_at_platform = float3( world_position.x, platform_position.y, world_position.z );
        float above_noise = fnoise( world_position_at_platform, above_platform_args.octaves, above_platform_args.frequency, above_platform_args.persistance, above_platform_args.lacunarity );

        float vertical_dst_from_platform = world_position.y - platform_position.y - ( platform_radius * 0.1 ) - ( above_noise * _PlatformTopDisplacement ); //pos above, neg below
        float side_multiplier = saturate( -( vertical_dst_from_platform / ( platform_radius * 0.1 ) ) );
        //. 1 radius above, -1 radius below, 0 at platform height


        NoiseArg platform_args = _NoiseArgs[1];
        float platform_shape_noise = fnoise01( world_position, platform_args.octaves, platform_args.frequency, platform_args.persistance, platform_args.lacunarity );
        platform_shape_noise = saturate( remap( platform_shape_noise, 0, 0.75, 0, 0.4 ) );
        
        float dst_from_platform = distance( world_position, platform_position );
        float radius_mask = saturate( -( dst_from_platform - platform_radius ) / ( platform_radius * 0.1) );

        float current_platform_shape = saturate( radius_mask * side_multiplier - radius_mask * platform_shape_noise );
        platform_total += current_platform_shape;
    }

    return platform_total;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    uint w, h, d;
    _Target.GetDimensions(w, h, d);
    if (id.x >= w || id.y >= h || id.z >= d) return;
    uint3 texture_size = uint3(w, h, d);

    float3 world_position = _ChunkOrigin + ( id * _VoxelScale );
    float3 inlayer_position = world_position - _LayerOrigin;

    float signed_dst_base_surface = GetSignedBaseSurfaceDistance( world_position );
    float base_surface = GetBaseShape( world_position, signed_dst_base_surface );
    //_Target[id] = base_surface; return;

    float platform = GetPlatformValue( world_position );
    float chasm = GetChasmMask( world_position );

    _Target[id] = max( base_surface, platform * chasm );
}
