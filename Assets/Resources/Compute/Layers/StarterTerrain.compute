#pragma kernel Generate
#include "../Noise/Fractal.cginc"
#include "../MathUtils.cginc"

//Features
#include "/Features/ChunkInfo.cginc"
#include "/Features/NoiseArgs.cginc"

RWTexture3D<float> _Target;

float _UpperSurfaceDepth;
float _UpperSurfaceFeatureDepth;
float2 _CliffLedgeSize;

float _UpperRadius;
float _LowerRadius;
float _CliffFeatureDepth;
int _CliffSlopeEasePower;

float _ChasmRadius;

float GetNormalizedHeightAtRadius(float radius){
    float linear_height = invlerp(radius, _UpperRadius, _LowerRadius);
    return easein( linear_height, 1.0 / _CliffSlopeEasePower );
}

float GetRadiusAtNormalizedHeight(float layer_normalized_height){
    float eased_height = easein( layer_normalized_height, _CliffSlopeEasePower );
    return lerp( _UpperRadius, _LowerRadius, eased_height );
}

//Platforms requires a GetRadiusAtNormalizedHeight definition
#include "/Features/Platforms.cginc"

//. -1 = 16 inside surface, 0, on surface, 1 = 16 outside surface
float GetSignedBaseSurfaceDistance(float3 world_position){
    float layer_normalized_height = ( -( world_position.y - _LayerOrigin.y ) ) / _LayerSize.y;
    float current_radius = GetRadiusAtNormalizedHeight( layer_normalized_height );

    float dst_from_centre = distance( world_position.xz, _LayerOrigin.xz );
    return clamp( ( dst_from_centre - current_radius ) / _CliffFeatureDepth, -1, 1 );
}

float GetBaseShape(float3 world_position, float signed_dst_base_surface){
    float base = saturate( signed_dst_base_surface + 0.5 );

    NoiseArg surface_noise_args = _NoiseArgs[4];
    float surface_noise = fnoise01( world_position * surface_noise_args.scale, surface_noise_args.octaves, surface_noise_args.frequency, surface_noise_args.persistance, surface_noise_args.lacunarity );

    return base + ( 1 - abs( signed_dst_base_surface ) ) * surface_noise;
}

float GetTopSurfaceMask(float3 world_position){
    float surface_world_height = _LayerOrigin.y - _UpperSurfaceDepth;
    float radius_at_surface = GetRadiusAtNormalizedHeight( -surface_world_height / _LayerSize.y );
    float lip_mask = saturate( ( abs( distance( world_position.xz, _LayerOrigin.xz ) - radius_at_surface ) ) / _CliffLedgeSize.x );
    surface_world_height -= easeinout( lip_mask, 4 ) * _CliffLedgeSize.y;

    NoiseArg top_surface_noise_args = _NoiseArgs[5];
    float3 sample_position = float3( world_position.x, _LayerOrigin.y, world_position.z );
    float top_surface_noise = fnoise01( sample_position * top_surface_noise_args.scale, top_surface_noise_args.octaves, top_surface_noise_args.frequency, top_surface_noise_args.persistance, top_surface_noise_args.lacunarity ) * 2 - 1;
    float noise_mask = 1 - saturate( abs( surface_world_height - world_position.y ) / _UpperSurfaceFeatureDepth );

    surface_world_height += top_surface_noise * noise_mask * max( 0.8, lip_mask ) * _UpperSurfaceFeatureDepth;

    return 1 - saturate( ( world_position.y - surface_world_height ) / _UpperSurfaceFeatureDepth );
}

float GetChasmMask(float3 world_position){
    //Possibly room to remove some temp variables here
    float3 chasm_centre = float3( _LayerOrigin.x, world_position.y, _LayerOrigin.z );
    float chasm_radius = _ChasmRadius;

    float dst_from_centre = distance( world_position, chasm_centre );

    float3 radial_dir = normalize( world_position - chasm_centre );
    float3 radial_position = chasm_centre + radial_dir * chasm_radius;
    NoiseArg radial_args = _NoiseArgs[2];
    float radial_noise = fnoise01( radial_position * radial_args.scale, radial_args.octaves, radial_args.frequency, radial_args.persistance, radial_args.lacunarity ) * 2 - 1;

    chasm_radius += radial_noise * min( 10, chasm_radius * 0.1 );

    float chasm_mask = saturate( ( dst_from_centre - chasm_radius ) / ( 16.0 ) );
    return chasm_mask;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    uint w, h, d;
    _Target.GetDimensions(w, h, d);
    if (id.x >= w || id.y >= h || id.z >= d) return;
    uint3 texture_size = uint3(w, h, d);

    float3 world_position = _ChunkOrigin + ( id * _VoxelScale );
    float3 inlayer_position = world_position - _LayerOrigin;

    float signed_dst_base_surface = GetSignedBaseSurfaceDistance( world_position );
    float base_surface = GetBaseShape( world_position, signed_dst_base_surface );
    float top_surface_mask = GetTopSurfaceMask( world_position );

    PlatformResult platform_result = GetPlatformValue( world_position );
    bool platform_stem_multiplier = distance(world_position.xz, _LayerOrigin.xz) > _LowerRadius;
    bool platform_multiplier = distance(world_position.xz, _LayerOrigin.xz) < (_UpperRadius + _CliffFeatureDepth * 0.5);
    float platform = max( platform_result.platformVal, platform_result.stemVal * platform_stem_multiplier );

    float chasm = GetChasmMask( world_position );

    _Target[id] = max( base_surface * top_surface_mask, platform * platform_multiplier );
}
