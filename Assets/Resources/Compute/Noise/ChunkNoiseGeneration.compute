#pragma kernel Generate

#include "/Fractal.cginc"
#include "../MathUtils.cginc"

struct LayerSettings {
    float3 origin;
    float depth;

    float topTransition;
    float bottomTransition;
    float chasmRadius;

    float groundThickness;
    float groundDepth;

    int octaves;
    float frequency;
    float persistance;
    float lacunarity;
};

//Const
StructuredBuffer<LayerSettings> _ChunkSettings;
int seed;
float voxel_scale;

//Variables
RWTexture3D<float> _DensityTexture;
float3 chunk_origin;
int layer_index;

float SampleDensity(float3 worldPos, LayerSettings settings) {
    //Texture-Space position of the sample point. /float3(256, 256, 256) is a bit arbitrary but it helps the frequency values be a bit more reasonable
    float3 samplePos = (float3(seed * 0.863, seed * 0.512, seed * 0.978) + (worldPos)) / float3(256, 256, 256);
    float depthPercent = saturate(invlerp(worldPos.y, settings.origin.y, settings.origin.y - settings.depth));

    //Carve out chasm
    float2 chasmCentre = float2(settings.origin.x, settings.origin.z);
    float dstFromChasmCentre = distance(chasmCentre, float2(worldPos.x, worldPos.z));
    float dstFromChasm = dstFromChasmCentre - settings.chasmRadius;
    float chasmRadiusFalloffDistance = 16;
    //0 -> 1 :: InChasm -> OutChasm
    float chasmMultiplier = saturate(remap(dstFromChasm + chasmRadiusFalloffDistance, 0, chasmRadiusFalloffDistance * 2, 0, 1));

    //Carve out ground
    float groundWorldHeight = settings.origin.y - settings.groundDepth;
    //<0 inside ground, >0 outside ground
    float dstFromGround = abs(worldPos.y - groundWorldHeight) - (settings.groundThickness / 2);
    float groundFalloffDistance = 16;
    float groundMultiplier = 1 - saturate(remap(dstFromGround, 0, groundFalloffDistance, 0, 1));

    float noise = fnoise01(samplePos, settings.octaves, settings.frequency, settings.persistance, settings.lacunarity);
    return noise * groundMultiplier * chasmMultiplier;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    //Texture dimensions and return condition
    uint width, height, depth;
    _DensityTexture.GetDimensions(width, height, depth);
    if (id.x >= width || id.y >= height || id.z >= depth) return;
    uint3 texture_size = uint3(width, height, depth);

    //Buffer information
    uint numLayers, stride;
    _ChunkSettings.GetDimensions(numLayers, stride);

    //Layer settings
    LayerSettings abvSettings = _ChunkSettings[max(0, layer_index-1)];
    LayerSettings curSettings = _ChunkSettings[layer_index];
    LayerSettings blwSettings = _ChunkSettings[min(numLayers-1, layer_index+1)];

    float3 voxelPosition = chunk_origin + (id * voxel_scale); //World-Space position of the sample point 

    //Handle top and bottom transitions
    //+1 and -1 on voxelPosition.y accounts for the fact that the layers kind of share texture points by nature since voxel vertices are placed between texture points
    //This therefore fixes the issue of having problems with layer transitions
    float abvLerp = saturate(invlerp(voxelPosition.y + 2 * voxel_scale, curSettings.origin.y - curSettings.topTransition, curSettings.origin.y));
    if (curSettings.topTransition == 0) abvLerp = 0;
    float blwLerp = saturate(invlerp(voxelPosition.y - 2 * voxel_scale, curSettings.origin.y - curSettings.depth + curSettings.bottomTransition, curSettings.origin.y - curSettings.depth));
    if (curSettings.bottomTransition == 0) blwLerp = 0;

    float abvDensity = SampleDensity(voxelPosition, abvSettings);
    float curDensity = SampleDensity(voxelPosition, curSettings);
    float blwDensity = SampleDensity(voxelPosition, blwSettings);

    float density = lerp(lerp(curDensity, abvDensity, abvLerp),
                         blwDensity, blwLerp);

    _DensityTexture[id.xyz] = density;
}
