#pragma kernel Generate

#include "/Fractal.cginc"
#include "../MathUtils.cginc"

struct LayerSettings {
    float3 origin;
    float depth;

    float topTransition;
    float bottomTransition;
    float chasmRadius;

    float groundThickness;
    float groundDepth;

    float groundHeightChangeMax;
    float groundHeightChangeScale;
    int groundHeightChangeComplexity;
    float groundHeightChangeDistortionStrength;

    float surfaceRoughness;
    float surfaceFeatureDepth;

    float pillarDensity;
    float pillarScale;
    int pillarIgnoreState;

    int octaves;
    float frequency;
    float persistance;
    float lacunarity;
};

//Const
StructuredBuffer<LayerSettings> _ChunkSettings;
int seed;
float voxel_scale;

//Variables
RWTexture3D<float> _DensityTexture;
float3 chunk_origin;
int layer_index;

float3 WorldPosToSamplePos(float3 worldPos) {
    return (float3(seed * 0.863, seed * 0.512, seed * 0.978) + (worldPos)) / float3(256, 256, 256);
}

//KEEP IN MIND <0.5 IS SOLID, >0.5 AIR
float SampleDensity(float3 worldPos, LayerSettings settings) {
    float3 samplePos = WorldPosToSamplePos(worldPos);

    //Carve out chasm
    float2 chasmCentre = float2(settings.origin.x, settings.origin.z);
    float dstFromChasmCentre = distance(chasmCentre, float2(worldPos.x, worldPos.z));
    float dstFromChasm = dstFromChasmCentre - settings.chasmRadius;
    float chasmRadiusFalloffDistance = 16;
    //0 -> 1 :: InChasm -> OutChasm
    float chasmMask = saturate(remap(dstFromChasm + chasmRadiusFalloffDistance, 0, chasmRadiusFalloffDistance * 2, 0, 1));

    //--GROUND--
    float groundCentreWorldY = settings.origin.y - settings.groundDepth;

    //--HEIGHT MAP CHANGE--
    //GOOD RANGE FOR HEIGHT CHANGE VALUES
    //OCTAVES = user_set
    //FREQUENCY = 0.001 - 0.005
    //PERSISTANCE = 0.6
    //LACUNARITY = 1.5
    float groundHeightChangeFrequency = lerp(0.15, 1.15, 1 - settings.groundHeightChangeScale);

    float3 groundCentreWorldPos = float3(worldPos.x, groundCentreWorldY, worldPos.z);
    float3 warpedGroundCentreWorldPos = warp_coords(groundCentreWorldPos, 5, groundHeightChangeFrequency / 6, 0.4, 1.6, settings.groundHeightChangeDistortionStrength);
    float3 warpedGroundCentreSamplePos = WorldPosToSamplePos(warpedGroundCentreWorldPos);
    float groundHeightChange = fnoise01(warpedGroundCentreSamplePos, settings.groundHeightChangeComplexity, groundHeightChangeFrequency, 0.6, 1.5) * 2 - 1;

    //<0 bottom side of ground, >0 top side of ground
    float dstFromGroundCentre = worldPos.y - groundCentreWorldY;
    float thicknessDelta = groundHeightChange * settings.groundHeightChangeMax * saturate(sign(dstFromGroundCentre) + 1) * 1.5 - 0.5; //Apply ground height change. saturate(sign(dstFromGroundCentre)) ensures that it is only added when above the centre line

    //<0 inside ground, >0 outside ground
    float dstFromGroundSurface = abs(dstFromGroundCentre) - (settings.groundThickness / 2 + thicknessDelta);
    float groundFalloffDistance = settings.groundThickness / 8; // Bit arbitrary
    float groundMask = 1 - saturate(remap(dstFromGroundSurface, 0, groundFalloffDistance, 0, 1));

    //--SURFACE TEXTURE--
    //==1 at surface, ==0 at surfaceFeatureDepth
    float surfaceMask = 1 - saturate(remap(abs(dstFromGroundSurface), 0, settings.surfaceFeatureDepth, 0, 1));

    //GOOD RANGE FOR SURFACE NOIES VALUES, CAN CHANGE
    //OCTAVES = 5
    //FREQUENCY = 1.2 - 3.8
    //PERSISTANCE = 0.6
    //LACUNARITY = 1.6 - 1.7
    float surfaceNoiseFrequency = lerp(1.2, 3.8, settings.surfaceRoughness);
    float surfaceNoiseLacunarity = lerp(1.6, 1.7, settings.surfaceRoughness);
    float surfaceNoise = fnoise01(samplePos, 5, surfaceNoiseFrequency, 0.6, surfaceNoiseLacunarity) * 2 - 1;

    //Adds high frequency noise to the inside of the ground, makes the edge of the chasm less uniform as a result
    float3 scaledInnerGroundWorldPos = float3(samplePos.x * 1.5, samplePos.y * 0.75, samplePos.z * 1.25);
    float innerGroundNoise = fnoise01(scaledInnerGroundWorldPos, 4, 3, 0.6, 1.5);

    //--CONNECTING STRANDS--
    float strandYScale = 42 / settings.depth; //perfect for 256
    float3 strandWorldPos = float3(worldPos.x, worldPos.y * strandYScale, worldPos.z);
    float3 strandWarpWorldPos = warp_coords(strandWorldPos, 4, 1.5, 0.5, 1.5, 0.5);
    float3 strandSamplePos = WorldPosToSamplePos(strandWarpWorldPos);
    
    //GOOD RANGE FOR CONNECTING STRANDS NOISE VALUES, CAN CHANGE
    //OCTAVES = 5
    //FREQUENCY = 1 - 5 --> Density and little bit scale
    //PERSISTANCE = 0.5
    //LACUNARITY = 1.7
    //THRESHOLD = 0.05 - 0.2 --> Density
    float strandNoiseFrequency = lerp(1, 5, settings.pillarDensity);
    float strandNoiseThreshold = lerp(0.05, 0.2, 1 - settings.pillarScale);
    float strandNoise = saturate(fnoise01(strandSamplePos, 5, strandNoiseFrequency, 0.5, 1.7) - strandNoiseThreshold);
    float strandIgnoreMultiplier = 1;
    if (sign(worldPos.y - groundCentreWorldY) == sign(settings.pillarIgnoreState)) strandIgnoreMultiplier = 0;
    if (settings.pillarIgnoreState == 2) strandIgnoreMultiplier = 0;


    float strandShape = strandNoise * chasmMask * (1 - groundMask) * strandIgnoreMultiplier;

    //float noise = fnoise01(samplePos, settings.octaves, settings.frequency, settings.persistance, settings.lacunarity);
    float result = 0;
    result += surfaceNoise * surfaceMask * chasmMask;
    result += groundMask * chasmMask;
    result += strandShape;
    result += innerGroundNoise * (groundMask * (1 - surfaceMask) * (chasmMask));
    return result;

    //return groundMask * chasmMask;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    //Texture dimensions and return condition
    uint width, height, depth;
    _DensityTexture.GetDimensions(width, height, depth);
    if (id.x >= width || id.y >= height || id.z >= depth) return;
    uint3 texture_size = uint3(width, height, depth);

    //Buffer information
    uint numLayers, stride;
    _ChunkSettings.GetDimensions(numLayers, stride);

    //Layer settings
    LayerSettings abvSettings = _ChunkSettings[max(0, layer_index-1)];
    LayerSettings curSettings = _ChunkSettings[layer_index];
    LayerSettings blwSettings = _ChunkSettings[min(numLayers-1, layer_index+1)];

    float3 voxelPosition = chunk_origin + (id * voxel_scale); //World-Space position of the sample point 

    //Handle top and bottom transitions
    //+1 and -1 on voxelPosition.y accounts for the fact that the layers kind of share texture points by nature since voxel vertices are placed between texture points
    //This therefore fixes the issue of having problems with layer transitions
    float abvLerp = saturate(invlerp(voxelPosition.y + 2 * voxel_scale, curSettings.origin.y - curSettings.topTransition, curSettings.origin.y));
    abvLerp *= sign(curSettings.topTransition);
    float blwLerp = saturate(invlerp(voxelPosition.y - 2 * voxel_scale, curSettings.origin.y - curSettings.depth + curSettings.bottomTransition, curSettings.origin.y - curSettings.depth));
    blwLerp *= sign(curSettings.bottomTransition);

    float abvDensity = SampleDensity(voxelPosition, abvSettings);
    float curDensity = SampleDensity(voxelPosition, curSettings);
    float blwDensity = SampleDensity(voxelPosition, blwSettings);

    float density = lerp(lerp(curDensity, abvDensity, abvLerp),
                         blwDensity, blwLerp);

    _DensityTexture[id.xyz] = density;
}
