#pragma kernel Generate

#include "/Fractal.cginc"
#include "../MathUtils.cginc"

struct LayerSettings {
    float topTransition;
    float bottomTransition;
    float chasmRadius;

    int octaves;
    float frequency;
    float persistance;
    float lacunarity;
};

//Const
StructuredBuffer<LayerSettings> _ChunkSettings;
int seed;
float voxel_scale;

//Variables
RWTexture3D<float> _DensityTexture;
float3 layer_origin;
float3 chunk_origin;
int layer_index;
float layer_depth;

float SampleDensity(float3 worldPos, LayerSettings settings) {
    //Texture-Space position of the sample point. /float3(256, 256, 256) is a bit arbitrary but it helps the frequency values be a bit more reasonable
    float3 samplePos = (float3(seed * 0.863, seed * 0.512, seed * 0.978) + (worldPos)) / float3(256, 256, 256);
    float depthPercent = saturate(invlerp(worldPos.y, layer_origin.y, layer_origin.y - layer_depth));

    //Carve out chasm
    float2 chasmCentre = float2(layer_origin.x, layer_origin.z);
    float dstFromChasmCentre = distance(chasmCentre, float2(worldPos.x, worldPos.z));
    float dstFromChasm = dstFromChasmCentre - settings.chasmRadius;
    float chasmRadiusFalloffDistance = 75;
    float chasmMultiplier = saturate(remap(dstFromChasm, 0, chasmRadiusFalloffDistance, 0, 1));

    float nraw = fnoise(samplePos, settings.octaves, settings.frequency, settings.persistance, settings.lacunarity);
    float nrange = fnoise_max(settings.persistance, settings.octaves);
    float noise = ((nraw / nrange) + 1) / 2;
    return noise * chasmMultiplier;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    //Texture dimensions and return condition
    uint width, height, depth;
    _DensityTexture.GetDimensions(width, height, depth);
    if (id.x >= width || id.y >= height || id.z >= depth) return;
    uint3 texture_size = uint3(width, height, depth);

    //Buffer information
    uint numLayers, stride;
    _ChunkSettings.GetDimensions(numLayers, stride);

    //Layer settings
    LayerSettings abvSettings = _ChunkSettings[max(0, layer_index-1)];
    LayerSettings curSettings = _ChunkSettings[layer_index];
    LayerSettings blwSettings = _ChunkSettings[min(numLayers-1, layer_index+1)];

    float3 voxelPosition = chunk_origin + (id * voxel_scale); //World-Space position of the sample point 

    //Handle top and bottom transitions
    //+1 and -1 on voxelPosition.y accounts for the fact that the layers kind of share texture points by nature since voxel vertices are placed between texture points
    //This therefore fixes the issue of having problems with layer transitions
    float abvLerp = saturate(invlerp(voxelPosition.y + 2 * voxel_scale, layer_origin.y - curSettings.topTransition, layer_origin.y));
    if (curSettings.topTransition == 0) abvLerp = 0;
    float blwLerp = saturate(invlerp(voxelPosition.y - 2 * voxel_scale, layer_origin.y - layer_depth + curSettings.bottomTransition, layer_origin.y - layer_depth));
    if (curSettings.bottomTransition == 0) blwLerp = 0;

    float abvDensity = SampleDensity(voxelPosition, abvSettings);
    float curDensity = SampleDensity(voxelPosition, curSettings);
    float blwDensity = SampleDensity(voxelPosition, blwSettings);

    float density = lerp(lerp(curDensity, abvDensity, abvLerp),
                         blwDensity, blwLerp);

    _DensityTexture[id.xyz] = density;
}
