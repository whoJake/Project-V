#pragma kernel Generate

#include "/Fractal.cginc"
#include "../MathUtils.cginc"

struct LayerSettings {
    float3 origin;
    float depth;

    float topTransition;
    float bottomTransition;
    float chasmRadius;

    float groundThickness;
    float groundDepth;

    float surfaceRoughness;
    float surfaceFeatureDepth;

    int octaves;
    float frequency;
    float persistance;
    float lacunarity;
};

//Const
StructuredBuffer<LayerSettings> _ChunkSettings;
int seed;
float voxel_scale;

//Variables
RWTexture3D<float> _DensityTexture;
float3 chunk_origin;
int layer_index;

//KEEP IN MIND <0.5 IS SOLID, >0.5 AIR
float SampleDensity(float3 worldPos, LayerSettings settings) {
    //Texture-Space position of the sample point. /float3(256, 256, 256) is a bit arbitrary but it helps the frequency values be a bit more reasonable
    float3 samplePos = (float3(seed * 0.863, seed * 0.512, seed * 0.978) + (worldPos)) / float3(256, 256, 256);
    float depthPercent = saturate(invlerp(worldPos.y, settings.origin.y, settings.origin.y - settings.depth));

    //Carve out chasm
    float2 chasmCentre = float2(settings.origin.x, settings.origin.z);
    float dstFromChasmCentre = distance(chasmCentre, float2(worldPos.x, worldPos.z));
    float dstFromChasm = dstFromChasmCentre - settings.chasmRadius;
    float chasmRadiusFalloffDistance = 16;
    //0 -> 1 :: InChasm -> OutChasm
    float chasmMask = saturate(remap(dstFromChasm + chasmRadiusFalloffDistance, 0, chasmRadiusFalloffDistance * 2, 0, 1));

    //Carve out ground
    float groundCentreWorldY = settings.origin.y - settings.groundDepth;
    //<0 bottom side of ground, >0 top side of ground
    float dstFromGroundCentre = worldPos.y - groundCentreWorldY;

    //<0 inside ground, >0 outside ground
    float dstFromGroundSurface = abs(dstFromGroundCentre) - (settings.groundThickness / 2);
    float groundFalloffDistance = settings.groundThickness / 8; // Bit arbitrary
    float groundMask = 1 - saturate(remap(dstFromGroundSurface, 0, groundFalloffDistance, 0, 1));

    //Add surface noise
    //==1 at surface, ==0 at groundFalloffDistance
    float surfaceMask = 1 - saturate(remap(abs(dstFromGroundSurface), 0, settings.surfaceFeatureDepth, 0, 1));

    //GOOD RANGE FOR SURFACE NOIES VALUES, CAN CHANGE
    //OCTAVES = 6
    //FREQUENCY = 1.2 - 3.8
    //PERSISTANCE = 0.6
    //LACUNARITY = 1.6 - 1.7
    float surfaceNoiseFrequency = lerp(1.2, 3.8, settings.surfaceRoughness);
    float surfaceNoiseLacunarity = lerp(1.6, 1.7, settings.surfaceRoughness);
    float surfaceNoise = fnoise01(samplePos, 6, surfaceNoiseFrequency, 0.6, surfaceNoiseLacunarity) * 2 - 1;

    float noise = fnoise01(samplePos, settings.octaves, settings.frequency, settings.persistance, settings.lacunarity);
    return surfaceNoise * surfaceMask * chasmMask + groundMask * chasmMask;
}

[numthreads(8,8,8)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    //Texture dimensions and return condition
    uint width, height, depth;
    _DensityTexture.GetDimensions(width, height, depth);
    if (id.x >= width || id.y >= height || id.z >= depth) return;
    uint3 texture_size = uint3(width, height, depth);

    //Buffer information
    uint numLayers, stride;
    _ChunkSettings.GetDimensions(numLayers, stride);

    //Layer settings
    LayerSettings abvSettings = _ChunkSettings[max(0, layer_index-1)];
    LayerSettings curSettings = _ChunkSettings[layer_index];
    LayerSettings blwSettings = _ChunkSettings[min(numLayers-1, layer_index+1)];

    float3 voxelPosition = chunk_origin + (id * voxel_scale); //World-Space position of the sample point 

    //Handle top and bottom transitions
    //+1 and -1 on voxelPosition.y accounts for the fact that the layers kind of share texture points by nature since voxel vertices are placed between texture points
    //This therefore fixes the issue of having problems with layer transitions
    float abvLerp = saturate(invlerp(voxelPosition.y + 2 * voxel_scale, curSettings.origin.y - curSettings.topTransition, curSettings.origin.y));
    if (curSettings.topTransition == 0) abvLerp = 0;
    float blwLerp = saturate(invlerp(voxelPosition.y - 2 * voxel_scale, curSettings.origin.y - curSettings.depth + curSettings.bottomTransition, curSettings.origin.y - curSettings.depth));
    if (curSettings.bottomTransition == 0) blwLerp = 0;

    float abvDensity = SampleDensity(voxelPosition, abvSettings);
    float curDensity = SampleDensity(voxelPosition, curSettings);
    float blwDensity = SampleDensity(voxelPosition, blwSettings);

    float density = lerp(lerp(curDensity, abvDensity, abvLerp),
                         blwDensity, blwLerp);

    _DensityTexture[id.xyz] = density;
}
